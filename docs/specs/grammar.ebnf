(* Oneil Language Grammar in EBNF *)

(* NOTE: Identifiers and keywords are assumed to be separated by whitespace, as
         is standard. So, `importabc` is parsed as a single token, not `import`
         followed by `abc`.
         
         In addition, inline whitespace (space and tabs) do not have any
         significance other than seperating tokens. Therefore, all tokens may
         optionally be separated by inline whitespace. *)

(* Whitespace and Comments *)
LineBreak = "\n" | "\r\n" ;  (* Each line break is a separate token *)
Comment = "#", { Any character except LineBreak }, LineBreak ;
EndOfLine = { LineBreak | Comment | ? end of file ? } ;
OptEndOfLine = [ EndOfLine ] ;

(* Top Level Structure *)
Model = [ EndOfLine ], [ Note ], { Declaration } { Section } ;
Declaration = ImportDecl | UseDecl | ParameterDecl | TestDecl ;

(* Notes *)
Note = SingleLineNote | MultiLineNote ;
SingleLineNote = "~", { Any character except LineBreak }, LineBreak ;
MultiLineNote = MultiLineNoteDelimiter, { NoteLine }, MultiLineNoteDelimiter ;
MultiLineNoteDelimiter = "~~~", "~"*, LineBreak ;
NoteLine = { Any character except LineBreak or MultiLineNoteDelimiter }, LineBreak ; (* can contain anything except the multi-note delimiter*)

(* Sections *)
Section = "section", Label, EndOfLine, [ Note ], { ImportDecl | UseDecl | ParameterDecl | TestDecl } ;

(* Imports *)
ImportDecl = "import", Identifier, EndOfLine ;
UseDecl = ("use" | "ref"), [ DirectoryPath ], ModelInfo, [ "with", SubmodelList ], EndOfLine ;
DirectoryPath = DirectoryName, "/", { DirectoryName, "/" } ;
DirectoryName = Identifier | ".." | "." ;
ModelInfo = Identifier, [ SubmodelComponents ], [ AsAlias ] ;
SubmodelComponents = ".", Identifier, { ".", Identifier }  ;
AsAlias = "as", Identifier ;
(* Note the optional trailing comma - this makes git diffs easier to read *)
SubmodelList = ModelInfo | "[", [ SubmodelListInner ], OptEndOfLine, "]" ;
SubmodelListInner = OptEndOfLine, ModelInfo, { ",", OptEndOfLine, ModelInfo }, [ "," ] ;

(* Parameters *)
ParameterDecl = [ Performance ], [ Trace ], Name, [ Limits ], ":", Assignment, EndOfLine, [ Note ] ;
Performance = "$" ;
Trace = "*" | "**" ;
Name = Label ;
Limits = ContinuousLimits | DiscreteLimits ;
ContinuousLimits = "(", Expr, ",", Expr, ")" ;
DiscreteLimits = "[", Expr, { ",", Expr }, "]" ;
Assignment = Identifier, "=", ( Expr [ ":", UnitExpr ] | PiecewiseExpr ) ;

(* Tests *)
TestDecl = [ Trace ], "test", ":", Expr, EndOfLine ;

(* Expressions *)
(* Expression Precedence (highest to lowest):
   1. Parentheses, function calls
   2. Unary minus (-)
   3. Exponentiation ( ** ) - right associative
   4. Multiplication, division, floor division, modulo (*, /, //, %) - left associative
   5. Addition, subtraction (+, -) - left associative
   6. Min/max (|) - non-associative
   6. Comparisons (<, >, <=, >=, ==, !=) - non-associative, can be chained
   7. NOT - unary prefix
   8. AND - left associative
   9. OR - left associative
*)
Expr = OrExpr ;
OrExpr = [ OrExpr, "or", ], AndExpr ;
AndExpr = [ AndExpr, "and", ], NotExpr ;
NotExpr = [ "not", ], NotExpr | ComparisonExpr ;
ComparisonExpr = AdditiveExpr, { ComparisonOp, AdditiveExpr } ;
ComparisonOp = "<" | ">" | "<=" | ">=" | "==" | "!=" ;
AdditiveExpr = [ AdditiveExpr, AdditiveOp, ], MultiplicativeExpr ;
AdditiveOp = "+" | "-" | "--" ;
MultiplicativeExpr = [ MultiplicativeExpr, MultiplicativeOp, ], ExponentialExpr ;
MultiplicativeOp = "*" | "/" | "//" | "%" ;
ExponentialExpr = NegExpr, [ "^", , ExponentialExpr ] ;  (* right associative *)
NegExpr = ( "-", NegExpr ) | PrimaryExpr ;
PrimaryExpr = NumberLiteral | StringLiteral | BooleanLiteral | Identifier [ ".", Identifier ] | FunctionCall | ( "(", Expr, ")" ) ;

PiecewiseExpr = PiecewisePart, [ ":", UnitExpr ], { EndOfLine, PiecewisePart } ;
PiecewisePart = "{", Expr, "if", Expr ;

(* Function Calls *)
FunctionCall = Identifier, "(", [ Expr, { ",", Expr } ], ")" ;

(* Units *)
UnitExpr = [ UnitExpr, ( "*" | "/" ) ], UnitTerm ;
UnitTerm = UnitIdentifier, [ "^", Number ] | UnitOne | ParenthesizedUnitExpr ;
UnitOne = "1" ; (* represents a unitless 1, usually used for units like 1/s *)
ParenthesizedUnitExpr = "(", UnitExpr, ")" ;

(* Basic Elements *)
Identifier = Letter, { Letter | Digit | "_" } ;
UnitIdentifier = Identifier, [ "$" ] | "$" | "%" ; (* A unit identifier may optionally be terminated by a dollar sign or may be a percent sign *)
(* note: labels are context sensitive since they can contain spaces and tabs *)
Label = LabelStartLetter, { LabelLetter }, { { " " | "\t" } LabelLetter { LabelLetter } } ;
LabelStartLetter = Any character except ( "(" | ")" | "[" | "]" | ":" | "=" | " " | "\t" | "\n" | "*" | "$" );
LabelLetter = Any character except ( "(" | ")" | "[" | "]" | ":" | "=" | " " | "\t" | "\n" );
NumberLiteral = [ Sign ], ( NumberPart, [ ExponentPart ] | "inf" ) ;
NumberPart = DigitSequence, [ ".", DigitSequence ] | ".", DigitSequence ;
DigitSequence = Digit, { Digit } ;
ExponentPart = ( "e" | "E" ), [ Sign ], DigitSequence ;
Sign = "+" | "-" ;
Letter = "A" | ... | "Z" | "a" | ... | "z" ;
Digit = "0" | "1" | ... | "9" ;
StringLiteral = "'", { Any character except LineBreak or "'" }, "'", ;
BooleanLiteral = "true" | "false" ;
