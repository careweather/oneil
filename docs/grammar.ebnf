(* Oneil Language Grammar in EBNF *)

(* NOTE: Identifiers and keywords are assumed to be separated by whitespace, as
         is standard. So, `importabc` is parsed as a single token, not `import`
         followed by `abc`.
         
         In addition, inline whitespace (space and tabs) do not have any
         significance other than seperating tokens. Therefore, all tokens may
         optionally be separated by inline whitespace. *)

(* Whitespace *)
LineBreak = "\n" | "\r\n" ;  (* Each line break is a separate token *)
EndOfLine = LineBreak | Comment | ? end of file ? ;

(* Top Level Structure *)
Program = [ Note ], { Declaration | Comment } ;
Declaration = ImportDecl | UseDecl | SectionDecl | ParameterDecl | TestDecl ;

(* Notes and Comments *)
Note = SingleLineNote | MultiLineNote ;
SingleLineNote = "~", { Any character except LineBreak }, LineBreak ;
MultiLineNote = MultiLineNoteDelimiter, { NoteLine }, MultiLineNoteDelimiter ;
MultiLineNoteDelimiter = "~~~", "~"*, LineBreak ;
NoteLine = { Any character except LineBreak or MultiLineNoteDelimiter }, LineBreak ; (* can contain anything except the multi-note delimiter*)
Comment = "#", { Any character except LineBreak }, LineBreak ;

(* Imports *)
ImportDecl = "import", Identifier, EndOfLine ;
UseDecl = [ "from", ModulePath ], "use", Model, [ ModelInputs ], "as", Identifier, EndOfLine ;
ModulePath = Identifier, { ".", Identifier } ;
ModelInputs = "(", Assignment, { ",", Assignment }, ")" ;
Model = Identifier ;  (* Model name without .on extension *)

(* Sections *)
SectionDecl = "section", Label, EndOfLine, [ Note ], { ImportDecl | UseDecl | ParameterDecl | TestDecl } ;

(* Parameters *)
ParameterDecl = [ Performance ], [ Trace ], Name, [ Limits ], ":", Assignment, EndOfLine, [ Note ] ;
Performance = "$" ;
Trace = "*" | "**" ;
Name = Label ;
Limits = ContinuousLimits | DiscreteLimits ;
ContinuousLimits = "(", ValueExpr, ",", ValueExpr, ")" ;
DiscreteLimits = "[", ValueExpr, { ",", ValueExpr }, "]" ;
Assignment = Identifier, "=", Expression ;

(* Tests *)
TestDecl = [ Trace ], "test", [ TestInputs ], ":", Expression, EndOfLine ;
TestInputs = "{", Identifier, { ",", Identifier }, "}" ;

(* Expressions *)
Expression = ValueExpr | PiecewiseExpr ;

(* Value Expression Precedence (highest to lowest):
   1. Parentheses, function calls
   2. Unary minus (-)
   3. Exponentiation ( ** ) - right associative
   4. Multiplication, division, floor division, modulo (*, /, //, %) - left associative
   5. Addition, subtraction (+, -) - left associative

   NOTE: values include both numeric and string values
*)
ValueExpr = AdditiveExpr, [ ":", UnitExpr ] ;
AdditiveExpr = [ AdditiveExpr, AdditiveOp, ], MultiplicativeExpr ;
AdditiveOp = "+" | "-" | "--" ;
MultiplicativeExpr = [ MultiplicativeExpr, MultiplicativeOp, ], ExponentialExpr ;
MultiplicativeOp = "*" | "/" | "//" | "%" ;
ExponentialExpr = NegExpr, [ "^", , ExponentialExpr ] ;  (* right associative *)
NegExpr = ( "-", NegExpr ) | PrimaryValueExpr ;
PrimaryValueExpr = Number | StringLiteral | Identifier { ".", Identifier } | FunctionCall | ( "(", ValueExpr, ")" ) ;

(* Boolean Expression Precedence (highest to lowest):
   1. Comparisons (<, >, <=, >=, ==, !=) - non-associative
   2. NOT - unary prefix
   3. AND - left associative
   4. OR - left associative
*)
BooleanExpr = OrExpr;
OrExpr = [ OrExpr, "or", ], AndExpr ;
AndExpr = [ AndExpr, "and", ], NotExpr ;
NotExpr = [ "not", ], NotExpr | ComparisonExpr ;
ComparisonExpr = PrimaryBooleanExpr, ComparisonOp, PrimaryBooleanExpr ;
ComparisonOp = "<" | ">" | "<=" | ">=" | "==" | "!=" ;
PrimaryBooleanExpr = ValueExpr ;

PiecewiseExpr = PiecewisePart, { EndOfLine, { EndOfLine }, PiecewisePart } ;
PiecewisePart = "{", ValueExpr, "if", BooleanExpr, [ ":", UnitExpr ], "}" ;

(* Function Calls *)
FunctionCall = Identifier, "(", [ Expression, { ",", Expression } ], ")" ;

(* Units *)
UnitExpr = UnitTerm, { ( "*" | "/" ), UnitTerm } ;
UnitTerm = Identifier, [ "^", Number ] | "(" UnitExpr, ")" ;

(* Basic Elements *)
Identifier = Letter, { Letter | Digit | "_" } ;
Label = Identifier, { "-" | Identifier } ;
Number = [ Sign ], ( Integer | Float | Scientific ) ;
Integer = Digit, { Digit } ;
Float = [ Integer ], ".", Digit, { Digit } ;
Scientific = ( Integer | Float ), ( "e" | "E" ), [ Sign ], Integer ;
Sign = "+" | "-" ;
Letter = "A" | ... | "Z" | "a" | ... | "z" ;
Digit = "0" | "1" | ... | "9" ;
StringLiteral = "\"", { Any character except LineBreak or "\" }, "\"", ;
